import os, sys
import logging
import random, string
from zipfile import ZipFile
from uuid import uuid4
from datetime import datetime, timedelta, timezone

from harvest.drivers.s3_driver import S3Driver

from harvest.controllers.photo_controller import PhotoController
from harvest.controllers.target_controller import TargetController
from harvest.controllers.place_controller import PlaceController

from harvest.utils.excel_doc_generator import ExcelDocGenerator
from harvest.utils.sorters import date_sort

PHOTOS_BUCKET_NAME="product-harvest-photos"
GENERATED_BUCKET_NAME="product-harvest-generated"
REPOSITORY_BUCKET_NAME="product-harvest-repository"
EXCEL_TEMPLATES="templates/excel/"

class GenerateController():

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  def __init__(self, host, port):
    self.photo = PhotoController(host, port)
    self.target = TargetController(host, port)
    self.place = PlaceController(host, port)
    self.__s3_photos = S3Driver(PHOTOS_BUCKET_NAME)
    self.__s3_gen = S3Driver(GENERATED_BUCKET_NAME)
    self.__s3_repo = S3Driver(REPOSITORY_BUCKET_NAME)
    self.__hierarchy_cache = {}

    self.logger.info("PHOTOS_BUCKET_NAME: {}".format(PHOTOS_BUCKET_NAME))
    self.logger.info("GENERATED_BUCKET_NAME: {}".format(GENERATED_BUCKET_NAME))
    self.logger.info("REPOSITORY_BUCKET_NAME: {}".format(REPOSITORY_BUCKET_NAME))
    self.logger.info("EXCEL_TEMPLATES: {}".format(EXCEL_TEMPLATES))

  def set_user_id(self, user_id):
    self.user_id = user_id

  def set_project_id(self, project_id):
    self.project_id = project_id

  def list(self, project_id=None):
    if not project_id:
      project_id = self.project_id

    ret = []
    objs = self.__s3_gen.list_objs(project_id)
    generated_files = [ obj["Key"] for obj in objs if obj["Key"] != project_id ]
    self.logger.info("generated files: %s" % str(generated_files))
    for obj in generated_files:
      tags = self.__s3_gen.get_obj_tags(obj)
      ret.append(tags)
    return ret

  def gen_hierarchy(self, places, place_id):
    hierarchy = []
    if place_id in self.__hierarchy_cache:
      hierarchy = self.__hierarchy_cache[place_id]
    else:
      for i in range(5):
        if place_id in places:
          hierarchy.insert(0, places[place_id]["name"])
          place_id = places[place_id]["parent_place_id"]
      if hierarchy:
        self.__hierarchy_cache.update({place_id: hierarchy})
    return hierarchy

  def convert_simple_place_dict(self, places):
    return { place["place_id"]: {"name": place["name"], "parent_place_id": place["parent_place_id"]} for place in places }

  def __get_photo_id_list(self, target, photo_type, all_photos=False):
    ret = []
    if all_photos:
      ret = [ photo_id for photo_id in target["photos"][photo_type] ]
    else:
      if isinstance(target["photos"]["adopt"][photo_type], str):
        ret.append(target["photos"]["adopt"][photo_type])
    self.logger.info("generate photo id list: %s" % str(ret))
    return ret

  def __get_photo_list(self, project_id, by_name=True, needs_sort=True, reverse=False, needs_include_hierarchy=False, needs_all_photos=False, needs_date=False):
    targets = self.target.list(project_id)

    if needs_include_hierarchy:
      places = self.place.list(project_id)
      self.logger.info("get under project places: %s" % str(places))
      places = self.convert_simple_place_dict(places)
      self.logger.info("convert places to simple dict: %s" % str(places))

    ret = []
    if by_name:
      before_name = "施工前"
      after_name = "施工後"
    else:
      before_name = "before"
      after_name = "after"

    for target in targets:
      hierarchy = []
      type_name = ""
      if needs_include_hierarchy:
        hierarchy = self.gen_hierarchy(places, target["parent_place_id"])
        self.logger.info("generate place hierarchy names: %s" % str(hierarchy))

      if by_name:
        name = target["name"]
      else:
        name = target["target_id"]

      for photo_type in ["before", "after"]:
        for photo_id in self.__get_photo_id_list(target, photo_type, all_photos=needs_all_photos):
          if photo_type == "before":
            type_name = before_name
          elif photo_type == "after":
            type_name = after_name

          created_at = target["updated_at"]
          if needs_date:
            tags = self.__s3_photos.get_obj_tags(photo_id)
            self.logger.info("object tags: {}".format(tags))
            if "created_at" in tags:
              created_at = tags["created_at"]

          ret.append({
              "name": name,
              "type": type_name,
              "photo": photo_id,
              "parent_place_id": target["parent_place_id"],
              "created_at": created_at,
              "hierarchy": hierarchy
          })

    self.logger.info("result photo list in target project: {}".format(str(ret)))
    if needs_sort:
      sorted_ret = date_sort(ret, key="created_at", reverse=reverse)
      ret = sorted_ret
      self.logger.info("sorted result photo list: {}".format(str(ret)))
    return ret

  def gen_zip(self, 
              project_id, 
              title, 
              by_name=True, 
              needs_include_hierarchy=False, 
              needs_make_dir=True, 
              workspace="/tmp", 
              needs_download_url=True, 
              needs_date=False,
              char_enc="utf_8",
              needs_all_photos=False):

    generated_file_id = str(uuid4())
    generated_filename = title + ".zip"
    local_workspace_path = os.path.join(workspace, str(uuid4()))
    local_result_path = os.path.join(local_workspace_path, generated_file_id)
    remote_result_path = "%s/%s/%s"  % (project_id, generated_file_id,  generated_filename)
    self.logger.info("generate zip file")
    self.logger.info("function argument 'project_id': {}".format(project_id))
    self.logger.info("function argument 'by_name': {}".format(by_name))
    self.logger.info("function argument 'workspace': {}".format(workspace))
    self.logger.info("function argument 'title': {}".format(title))
    self.logger.info("function argument 'needs_download_url': {}".format(needs_download_url))
    self.logger.info("function argument 'needs_include_hierarchy': {}".format(needs_include_hierarchy))
    self.logger.info("function argument 'needs_make_dir': {}".format(needs_make_dir))
    self.logger.info("function argument 'needs_all_photos': {}".format(needs_all_photos))
    self.logger.info("function argument 'needs_date': {}".format(needs_date))
    self.logger.info("generated_file_id: {}".format(generated_file_id))
    self.logger.info("generated_filename: {}".format(generated_filename))
    self.logger.info("local_workspace_path: {}".format(local_workspace_path))
    self.logger.info("local_result_path: {}".format(local_result_path))
    self.logger.info("remote_result_path: {}".format(remote_result_path))
    self.logger.info("filename char encode: {}".format(char_enc))

    if not os.path.exists(local_workspace_path):
      os.mkdir(local_workspace_path)

    if char_enc not in ["utf_8", "shift_jis"]:
      char_enc = "utf_8"

    duplicate_names = []

    with ZipFile(local_result_path, 'w') as result_zip:
      for photo in self.__get_photo_list(project_id, by_name=by_name, needs_sort=False, needs_include_hierarchy=needs_include_hierarchy, needs_all_photos=needs_all_photos, needs_date=needs_date):
        self.logger.info(photo)
        filename = os.path.join(workspace, photo["photo"])
        self.logger.info("loading filename: %s" % filename)

        if needs_include_hierarchy and photo["hierarchy"]:
          if needs_make_dir:
            hierarchy_names = "/".join(photo["hierarchy"])
            inzip_filename = "{}/{}_{}".format(hierarchy_names, photo["name"], photo["type"])
          else:
            hierarchy_names = "_".join(photo["hierarchy"])
            inzip_filename = "{}_{}_{}".format(hierarchy_names, photo["name"], photo["type"])
        else:
          inzip_filename = "{}_{}".format(photo["name"], photo["type"])

        if needs_date:
          inzip_filename += "_" + self.iso8601_to_simple(photo["created_at"])

        if inzip_filename in duplicate_names:
          self.logger.info("detected duplicate filename. apeend random strings.")
          inzip_filename += "_" + self.__get_random_str()
        self.logger.info("write filename in zip: %s" % inzip_filename)
        duplicate_names.append(inzip_filename)

        try:
          self.__s3_photos.download_obj(photo["photo"], filename)
          # TODO: 今はshift-jisのみ。いずれ文字コードの切り替えをしたい。
          result_zip.write(filename=filename, arcname=inzip_filename + ".jpg")
        except Exception as e:
          self.logger.error("generate photo zip file failed... exception error occurred.")
          self.logger.exception(e)
          raise Exception
    self.__s3_gen.upload_obj(local_result_path, remote_result_path)
    tags = {
      "generated_file_id": generated_file_id,
      "created_at": datetime.now().isoformat(),
      "created_by": self.user_id,
      "project_id": project_id,
      "name": title + ".zip",
      "type": "zip"
    }
    self.__s3_gen.put_obj_tags(remote_result_path, tags)

    ret = ""
    if needs_download_url:
      url = self.__s3_gen.create_presigned_url(remote_result_path)
      ret = { 
          "download_url": url,
          "name": title + ".zip"
      }
      self.logger.info("generated download url: {}".format(url))
    else:
      ret = remote_result_path
    return ret

  def create_download_url(self, project_id, gen_type=None):
    url = ""
    if gen_type == "zip":
      self.logger.info("exec start")
      uniq_name = str(uuid4()) + ".zip"
      obj_key = self.gen_zip(project_id, result_name=uniq_name)
      url = self.__s3_gen.create_presigned_url(obj_key)
      self.logger.info("generated download url: {}".format(url))

    return url

  def gen_excel_doc(self, 
                    project_id, 
                    title,
                    needs_sort=True, 
                    needs_include_hierarchy=False, 
                    needs_date=False,
                    workspace="/tmp", 
                    template="basic_1.xlsx", 
                    needs_download_url=True):

    generated_file_id = str(uuid4())
    generated_filename = title + ".xlsx"
    local_workspace_path = os.path.join(workspace, str(uuid4()))
    local_template_path = os.path.join(local_workspace_path, template)
    local_result_path = os.path.join(local_workspace_path, generated_filename)
    remote_result_path = "%s/%s/%s"  % (project_id, generated_file_id,  generated_filename)
    self.logger.info("generate excel document")
    self.logger.info("function argument 'project_id': {}".format(project_id))
    self.logger.info("function argument 'needs_include_hierarchy': {}".format(needs_include_hierarchy))
    self.logger.info("function argument 'workspace': {}".format(workspace))
    self.logger.info("function argument 'template': {}".format(template))
    self.logger.info("function argument 'title': {}".format(title))
    self.logger.info("function argument 'needs_download_url': {}".format(needs_download_url))
    self.logger.info("function argument 'needs_date': {}".format(needs_date))
    self.logger.info("generated_file_id: {}".format(generated_file_id))
    self.logger.info("generated_filename: {}".format(generated_filename))
    self.logger.info("local_workspace_path: {}".format(local_workspace_path))
    self.logger.info("local_template_path: {}".format(local_template_path))
    self.logger.info("local_result_path: {}".format(local_result_path))

    # templateのcustom属性で判断
    remote_template_path = "templates/excel/defaults/{}".format(template)
    #if needs_custom_template:
    #  #remote_template_path = "templates/excel/{}/{}".format(project_id, template)
    #  remote_template_path = "templates/excel/defaults/{}".format(template)
    #else:
    #  remote_template_path = "templates/excel/defaults/{}".format(template)

    if not os.path.exists(local_workspace_path):
      os.mkdir(local_workspace_path)

    photo_list = self.__get_photo_list(project_id, needs_sort=needs_sort, needs_include_hierarchy=needs_include_hierarchy, needs_date=needs_date)

    # TODO: photo_listが見つからなかったときに例外なげる
    for photo in photo_list:
      self.logger.info("processing target photo: {}".format(photo))
      filename = os.path.join(local_workspace_path, photo["photo"])
      self.logger.info("filename: {}".format(filename))
      try:
        self.__s3_photos.download_obj(photo["photo"], filename)

      except Exception as e:
        self.logger.info(e)
        return e

    # s3から指定のテンプレxlsxを落としてくる
    self.logger.info("remote_template_path: {}".format(remote_template_path))
    self.__s3_repo.download_obj(remote_template_path, local_template_path)
    if not os.path.exists(local_template_path):
      raise Exception
    self.logger.info("template download done")

    excel = ExcelDocGenerator(local_template_path)
    excel.generate(
      title=title, 
      items=photo_list, 
      save_filename=local_result_path, 
      needs_include_hierarchy=needs_include_hierarchy, 
      needs_date=needs_date,
      workspace=local_workspace_path
    )
    self.__s3_gen.upload_obj(local_result_path, remote_result_path)
    tags = {
      "generated_file_id": generated_file_id,
      "created_at": datetime.now().isoformat(),
      "created_by": self.user_id,
      "project_id": project_id,
      "name": generated_filename,
      "type": "excel"
    }
    self.__s3_gen.put_obj_tags(remote_result_path, tags)

    ret = ""
    if needs_download_url:
      url = self.__s3_gen.create_presigned_url(remote_result_path)
      ret = { 
          "download_url": url,
          "name": generated_filename
      }
      self.logger.info("generated download url: {}".format(url))
    else:
      ret = remote_result_path
    return ret

  def gen_download_url(self, generated_file_id, project_id=None):
    if not project_id:
      project_id = self.project_id
    path = project_id + "/" + generated_file_id

    objs = self.__s3_gen.list_objs(path)
    generated_file = [ obj["Key"] for obj in objs if obj["Key"] != path ]
    tags = self.__s3_gen.get_obj_tags(generated_file[0])
    url = self.__s3_gen.create_presigned_url(generated_file[0])
    self.logger.info("generated download url: {}".format(url))
    return { 
        "download_url": url,
        "name": tags["name"]
    }

  def __get_random_str(self):
     return ''.join(random.choices(string.ascii_letters + string.digits, k=4))

  def iso8601_to_simple(self, iso8601):
    dt = datetime.strptime(iso8601, "%Y-%m-%dT%H:%M:%S.%f")
    dt_jst = dt.astimezone(timezone(timedelta(hours=+9)))
    return datetime.strftime(dt_jst, "%Y%m%d%H%M%S")

import os, sys
import logging
from zipfile import ZipFile
from uuid import uuid4

from harvest.drivers.s3_driver import S3Driver

from harvest.controllers.role_controller import RoleController
from harvest.controllers.photo_controller import PhotoController
from harvest.controllers.target_controller import TargetController

from harvest.utils.excel_doc_generator import ExcelDocGenerator
from harvest.utils.sorters import date_sort

PHOTOS_BUCKET_NAME="product-harvest-photos"
GENERATED_BUCKET_NAME="product-harvest-generated"
REPOSITORY_BUCKET_NAME="product-harvest-repository"
EXCEL_TEMPLATES="templates/excel/"

class GenerateController():

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  def __init__(self, host, port):
    self.photo = PhotoController(host, port)
    self.target = TargetController(host, port)
    self.role = RoleController(host, port)
    self.__s3_photos = S3Driver(PHOTOS_BUCKET_NAME)
    self.__s3_gen = S3Driver(GENERATED_BUCKET_NAME)
    self.__s3_repo = S3Driver(REPOSITORY_BUCKET_NAME)

    self.logger.info("PHOTOS_BUCKET_NAME: {}".format(PHOTOS_BUCKET_NAME))
    self.logger.info("GENERATED_BUCKET_NAME: {}".format(GENERATED_BUCKET_NAME))
    self.logger.info("REPOSITORY_BUCKET_NAME: {}".format(REPOSITORY_BUCKET_NAME))
    self.logger.info("EXCEL_TEMPLATES: {}".format(EXCEL_TEMPLATES))

  def __get_photo_list(self, project_id, by_name=True, needs_sort=True, reverse=False):
    targets = self.target.list(project_id)
    ret = []
    for target in targets:
      if by_name:
        name = target["name"]
        before_name = "施工前"
        after_name = "施工後"
      else:
        name = target["target_id"]
        before_name = "before"
        after_name = "after"

      if isinstance(target["photos"]["adopt"]["before"], str):
        ret.append({
            "name": name,
            "type": before_name,
            "photo": target["photos"]["adopt"]["before"],
            "created_at": target["created_at"],
            "updated_at": target["updated_at"]
        })
      if isinstance(target["photos"]["adopt"]["after"], str):
        ret.append({
            "name": name,
            "type": after_name,
            "photo": target["photos"]["adopt"]["after"],
            "created_at": target["created_at"],
            "updated_at": target["updated_at"]
        })
    self.logger.info("result photo list in target project: {}".format(str(ret)))
    if needs_sort:
      sorted_ret = date_sort(ret, key="created_at", reverse=reverse)
      ret = sorted_ret
      self.logger.info("sorted result photo list: {}".format(str(ret)))
    return ret

  def gen_zip(self, project_id, by_name=True, workspace="/tmp", result_filename="photos_result.zip", needs_download_url=True, char_enc="utf_8"):
    local_workspace_path = os.path.join(workspace, str(uuid4()))
    local_result_path = os.path.join(local_workspace_path, result_filename)
    remote_result_path = project_id + "/" + result_filename
    self.logger.info("generate zip file")
    self.logger.info("function argument 'project_id': {}".format(project_id))
    self.logger.info("function argument 'by_name': {}".format(by_name))
    self.logger.info("function argument 'workspace': {}".format(workspace))
    self.logger.info("function argument 'result_filename': {}".format(result_filename))
    self.logger.info("function argument 'needs_download_url': {}".format(needs_download_url))
    self.logger.info("local_workspace_path: {}".format(local_workspace_path))
    self.logger.info("local_result_path: {}".format(local_result_path))
    self.logger.info("remote_result_path: {}".format(remote_result_path))
    self.logger.info("filename char encode: {}".format(char_enc))

    if not os.path.exists(local_workspace_path):
      os.mkdir(local_workspace_path)

    if char_enc not in ["utf_8", "shift_jis"]:
      char_enc = "utf_8"

    with ZipFile(local_result_path, 'w') as result_zip:
      for photo in self.__get_photo_list(project_id, by_name=by_name, needs_sort=False):
        self.logger.info(photo)
        filename = os.path.join(workspace, photo["photo"])
        self.logger.info(filename)
        try:
          self.__s3_photos.download_obj(photo["photo"], filename)
          # TODO: 今はshift-jisのみ。いずれ文字コードの切り替えをしたい。
          result_zip.write(filename=filename, arcname="{}_{}.jpg".format(photo["name"], photo["type"]))
        except Exception as e:
          self.logger.error("generate photo zip file failed... exception error occurred.")
          self.logger.exception(e)
          raise Exception
    self.__s3_gen.upload_obj(local_result_path, remote_result_path)

    ret = ""
    if needs_download_url:
      ret = self.__s3_gen.create_presigned_url(remote_result_path)
    else:
      ret = remote_result_path
    return ret

  def create_download_url(self, project_id, gen_type=None):
    url = ""
    if gen_type == "zip":
      self.logger.info("exec start")
      uniq_name = str(uuid4()) + ".zip"
      obj_key = self.gen_zip(project_id, result_name=uniq_name)
      url = self.__s3_gen.create_presigned_url(obj_key)
      self.logger.info("generated download url: {}".format(url))

    return url

  def gen_excel_doc(self, project_id, needs_sort=True, has_hierarchy=False, workspace="/tmp", template="basic_1.xlsx", result_filename="photos_result.xlsx", needs_download_url=True):
    local_workspace_path = os.path.join(workspace, str(uuid4()))
    local_template_path = os.path.join(local_workspace_path, template)
    local_result_path = os.path.join(local_workspace_path, result_filename)
    self.logger.info("generate excel document")
    self.logger.info("function argument 'project_id': {}".format(project_id))
    self.logger.info("function argument 'has_hierarchy': {}".format(has_hierarchy))
    self.logger.info("function argument 'workspace': {}".format(workspace))
    self.logger.info("function argument 'template': {}".format(template))
    self.logger.info("function argument 'result_filename': {}".format(result_filename))
    self.logger.info("function argument 'needs_download_url': {}".format(needs_download_url))
    self.logger.info("local_workspace_path: {}".format(local_workspace_path))
    self.logger.info("local_template_path: {}".format(local_template_path))
    self.logger.info("local_result_path: {}".format(local_result_path))

    # templateのcustom属性で判断
    remote_template_path = "templates/excel/defaults/{}".format(template)
    #if needs_custom_template:
    #  #remote_template_path = "templates/excel/{}/{}".format(project_id, template)
    #  remote_template_path = "templates/excel/defaults/{}".format(template)
    #else:
    #  remote_template_path = "templates/excel/defaults/{}".format(template)
    remote_result_path = project_id + "/" + result_filename

    if not os.path.exists(local_workspace_path):
      os.mkdir(local_workspace_path)

    photo_list = self.__get_photo_list(project_id, needs_sort=needs_sort)

    # TODO: photo_listが見つからなかったときに例外なげる
    for photo in photo_list:
      self.logger.info("processing target photo: {}".format(photo))
      filename = os.path.join(workspace, photo["photo"])
      self.logger.info("filename: {}".format(filename))
      try:
        self.__s3_photos.download_obj(photo["photo"], filename)

      except Exception as e:
        self.logger.info(e)
        return e

    # s3から指定のテンプレxlsxを落としてくる
    self.logger.info("remote_template_path: {}".format(remote_template_path))
    self.__s3_repo.download_obj(remote_template_path, local_template_path)

    excel = ExcelDocGenerator(local_template_path)
    excel.generate(photo_list, local_result_path)
    self.__s3_gen.upload_obj(local_result_path, remote_result_path)

    ret = ""
    if needs_download_url:
      ret = self.__s3_gen.create_presigned_url(remote_result_path)
      self.logger.info("generated download url: {}".format(ret))
    else:
      ret = remote_result_path
    return ret

import os, sys
import json
import logging
from uuid import uuid4
from datetime import datetime

from harvest.drivers.dynamodb_driver import DynamoDbDriver
from harvest.drivers.s3_driver import S3Driver
from harvest.controllers.place_controller import PlaceController

BUCKET_NAME="product-harvest-photos"

class TargetController(DynamoDbDriver):

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  def __init__(self, host, port):
    super().__init__(host, port, "Targets")
    super().set_partition_key("project_id")
    super().set_sort_key("target_id")
    self.place = PlaceController(host, port)
    self.__s3 = S3Driver(BUCKET_NAME)

  def set_project_id(self, project_id):
    self.project_id = str(project_id)
    self.place.set_project_id(self.project_id)
  
  def set_target_id(self, target_id):
    self.target_id = str(target_id)

  def list(self, project_id=None):
    if not project_id and self.project_id:
      project_id = self.project_id
    
    ret = super().query(
        partition_key = project_id
    )
    return ret["Items"]

  def list_children(self, parent_place_id):
    if not self.project_id or not parent_place_id:
      raise ValueError

    super().set_sort_key("parent_place_id")
    ret = super().query(
        partition_key = self.project_id, 
        sort_key = parent_place_id, 
        index = "ParentPlacesIndex"
    )
    super().set_sort_key("target_id")
    return ret["Items"]

  def show(self, target_id = None):
    if not self.project_id:
      raise ValueError
    if not target_id:
      target_id = self.target_id
    # user_idを使って権限チェック
    return super().get_item(self.project_id, target_id)["Item"]

  def create(self, name, parent_place_id = None):
    if not self.project_id or not name:
      raise ValueError
    
    if parent_place_id:
      # 親placeを取得
      parent = self.place.show(parent_place_id)
      hierarchy = parent["hierarchy"]
      # ヒエラルキに親place_idを足す
      hierarchy += "#{}".format(parent_place_id)
      hierarchy = hierarchy.split("#")
      if hierarchy[0] == self.project_id:
        del hierarchy[0]
        self.logger.info("root_place found.")
    else:
      parent_place_id = self.project_id
      hierarchy = None

    #TODO: important ここもトランザクション処理させないと、ここが成功して次が失敗したときの影響が大きすぎる
    new_id = str(uuid4())
    now = datetime.now().isoformat()
    transact_items = []
    transact_items.append(
        {
          'Put': {
            'TableName': "Targets",
            'Item': {
              'project_id': {'S': self.project_id},
              'target_id': {'S': new_id},
              'parent_place_id': {'S': parent_place_id},
              'name': {'S': str(name)},
              'photos': {'M': {
                'adopt': {'M': {
                  'before': {'NULL': True},
                  'after': {'NULL': True}
                }},
                "before": {'L': []},
                "after": {'L': []}
              }},
              'created_at': {'S': now},
              'updated_at': {'S': now}
            }
          }
        }
    )

    if hierarchy:
      for place_id in hierarchy:
        transact_items.append(
            {
              'Update': {
                'TableName': "Places",
                'Key': {
                  'project_id': {'S': self.project_id},
                  'place_id': {'S': place_id}
                },
                'ConditionExpression': 'attribute_exists(project_id)',
                'UpdateExpression': 'set photos.required = photos.required + :p',
                'ExpressionAttributeValues': {":p": {"N":"1"}}
              }
            }
        )
    self.logger.info("execute transcat write items: {}".format(transact_items))
    ret = self.client.transact_write_items(
        ReturnConsumedCapacity = 'INDEXES',
        TransactItems = transact_items
    )
    self.logger.info("transact_write_items result: {}".format(str(ret)))
    return ret

  def update_name(self, name):
    if not self.project_id or not self.target_id:
      raise ValueError

    # user_idを使って権限チェック
    now = datetime.now().isoformat()
    return super().update_item(
        partition_key = self.project_id,
        sort_key = self.target_id,
        update_exp = "set #name = :name, #updated_at = :updated_at",
        exp_attr_names = {
            '#name': "name",
            "#updated_at": "updated_at"
        },
        exp_attr_values={
            ":name": name,
            ":updated_at": now

        },
        cond_exp = 'attribute_exists(project_id)'
    )

  def delete(self, target_id=None):
    if not self.project_id or not self.target_id:
      raise ValueError
    if target_id:
      target_id = self.target_id
    
    transact_items = []
    photo_ids = []
    # targetを取得
    target = self.show(target_id)
    if target["project_id"] == target["parent_place_id"]:
      # project直下である場合
      hierarchy = []
    else:
      # parent_place_idを使ってplaceを取得
      parent = self.place.show(target["parent_place_id"])
      hierarchy = parent["hierarchy"]
      # ヒエラルキに親place_idを足す
      hierarchy += "#{}".format(target["parent_place_id"])
      hierarchy = hierarchy.split("#")
      if hierarchy[0] == self.project_id:
        del hierarchy[0]

    # adoptがあるなら写真撮影済みということ
    # 写真があるなら、placeのresult側も削除しないといけない
    cond_exp = 'set photos.required = photos.required - :p, #updated_at = :updated_at'
    exp_attr_name = {"#updated_at": "updated_at"}
    for type in ["before", "after"]:
      if target["photos"]["adopt"][type]:
        cond_exp += ', photos.results.#{} = photos.results.#{} - :p'.format(type, type)
        photo_ids.extend(target["photos"][type])
        exp_attr_name.update({"#" + type: type})

    now = datetime.now().isoformat()
    transact_items.append(
        {
          'Delete': {
            'TableName': "Targets",
            'Key': {
              'project_id': {'S': self.project_id},
              'target_id': {'S': target_id}
            },
            'ConditionExpression': 'attribute_exists(project_id)'
          }
        }
    )
    for place_id in hierarchy:
      transact_items.append(
          {
            'Update': {
              'TableName': "Places",
              'Key': {
                'project_id': {'S': self.project_id},
                'place_id': {'S': place_id}
              },
              'ConditionExpression': 'attribute_exists(project_id)',
              'UpdateExpression': cond_exp,
              'ExpressionAttributeValues': {
                  ":p": {"N": "1"},
                  ":updated_at": {"S": now}
              },
              'ExpressionAttributeNames': exp_attr_name
            }
          }
      )
    self.logger.info("execute transcat write items: {}".format(transact_items))
    ret = self.client.transact_write_items(
        ReturnConsumedCapacity = 'INDEXES',
        TransactItems = transact_items
    )
    self.logger.info("transact_write_items result: {}".format(str(ret)))
    # s3の画像を全て削除
    if ret:
      for photo_id in photo_ids:
        ret = self.__s3.delete_obj(photo_id)
    return

  def delete_all(self):
    if not self.project_id:
      raise ValueError

    target_ids = []
    photo_ids = []
    targets = self.list()
    for target in targets:
      photo_ids.extend(target["photos"]["before"])
      photo_ids.extend(target["photos"]["after"])
      target_ids.append({"project_id": self.project_id, "target_id": target["target_id"]})

    results = []
    results.append(
        super().batch_del_item(target_ids)
    )
    for photo_id in photo_ids:
      results.append(
          self.__s3.delete_obj(photo_id)
      )
    return results

  def batch_create_targets(self, targets):
    return super().batch_put_item(targets)
    #loop_cnt = 1
    #if len(targets) > 25:
    #  loop_cnt = targets / 25
    #  loop_cnt += (targets % 25)

    #req_items = []
    #for target in targets:
    #  req_items.append(
    #    {
    #      'PutRequest': {
    #        'Item': target
    #      }
    #    }
    #  )
    #results = []
    #for i in range(loop_cnt):
    #  ret = self.dynamodb.batch_write_item(
    #        RequestItems = {
    #          "Targets": req_items[:25]
    #        }
    #  )
    #  results.append(ret)
    #  del req_items[:25]
    #TODO: batch_writeが失敗していたときの処理が必要

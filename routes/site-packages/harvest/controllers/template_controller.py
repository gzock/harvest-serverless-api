import os, sys
import logging
from uuid import uuid4
from datetime import datetime, timedelta, timezone

from harvest.drivers.s3_driver import S3Driver

from harvest.utils.excel_doc_generator import ExcelDocGenerator

REPOSITORY_BUCKET_NAME="product-harvest-repository"

BASE_TEMPLATES_PATH="templates/excel/"
DEFAULT_TEMPLATES_PATH=BASE_TEMPLATES_PATH + "defaults/"
USERS_TEMPLATES_PATH=BASE_TEMPLATES_PATH + "users/"
PROJECTS_TEMPLATES_PATH=BASE_TEMPLATES_PATH + "projects/"

BASE_LOCAL_WORKSPACE_PATH="/tmp"
LOCAL_WORKSPACE_PATH = os.path.join(BASE_LOCAL_WORKSPACE_PATH, str(uuid4()))

class TemplateController():

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  user_id = None
  project_id = None
  template_id = None

  def __init__(self):
    self.__repo = S3Driver(REPOSITORY_BUCKET_NAME)

    self.logger.info("REPOSITORY_BUCKET_NAME: {}".format(REPOSITORY_BUCKET_NAME))
    self.logger.info("DEFAULT_TEMPLATES_PATH: {}".format(DEFAULT_TEMPLATES_PATH))
    self.logger.info("USERS_TEMPLATES_PATH: {}".format(USERS_TEMPLATES_PATH))
    self.logger.info("PROJECTS_TEMPLATES_PATH: {}".format(PROJECTS_TEMPLATES_PATH))
    self.logger.info("LOCAL_WORKSPACE_PATH: {}".format(LOCAL_WORKSPACE_PATH))

  def set_user_id(self, user_id):
    self.user_id = user_id

  def set_projet_id(self, project_id):
    self.project_id = project_id

  def get_template_path(self, template_id):
    # バケットを組み合わせたオブジェクトへ対するパスを生成
    if self.user_id:
      user_tmpls = list_user_templates(self.user_id)
      if template_id in [ tmpl["Key"] for tmpl in user_tmpls ]:
        return USERS_TEMPLATES_PATH + template_id

    if self.project_id:
      project_tmpls = list_project_templates(self.project_id)
      if template_id in [ tmpl["Key"] for tmpl in user_tmpls ]:
        return PROJECTS_TEMPLATES_PATH + template_id

    default_tmpls = list_default_templates()
    if template_id in [ tmpl["Key"] for tmpl in user_tmpls ]:
      return DEFAULT_TEMPLATES_PATH + template_id
    else:
      # TODO: 存在しないテンプレートを指定されたときの例外処理
      raise Exception

  def get(self, template_id, needs_download_url=False):
    # template_idからprefixを生成
    template_path = self.get_template_path(template_id)

    # s3からオブジェクト取得
    # TODO: bytesで返すことも考慮？
    local_template_path = os.path.join(LOCAL_WORKSPACE_PATH, template_id)

    if needs_download_url:
      ret = self.__repo.create_presigned_url(template_path)
      self.logger.info("generated download url: {}".format(ret))

    else:
      self.__repo.download_obj(template_path, local_template_path)
      if not os.path.exists(local_template_path):
        raise Exception
      self.logger.info("template download done")
      ret = local_template_path

    return ret

  def list(self, user_id=None, project_id=None):
    if not user_id:
      user_id = self.user_id
    if not project_id:
      project_id = self.project_id
    
    default_tmpl = self.list_default_templates()
    ret = {
        "default": default_tmpl
    }
    if user_id:
      user_tmpl = self.list_user_templates(user_id)
      ret.update({"user": user_tmpl})

    if project_id:
      project_tmpl = self.list_project_templates(project_id)
      ret.update({"project": project_tmpl})

    return ret

  def __list_templates(self, template_type, any_id=None):
    if template_type is "default":
      path = DEFAULT_TEMPLATES_PATH
    elif template_type is "user" and any_id:
      path = USERS_TEMPLATES_PATH + any_id
    elif template_type is "project" and any_id:
      path = PROJECTS_TEMPLATES_PATH + any_id
    else:
      raise Exception

    ret = []
    objs = self.__repo.list_objs(path)
    template_names = [ obj["Key"] for obj in objs if obj["Key"] != DEFAULT_TEMPLATES_PATH ]
    for name in template_names:
      tags = self.__repo.get_obj_tags(name)
      tags.update({"template_id": name.split("/")[-1]})
      ret.append(tags)
    return ret

  def list_default_templates(self):
    return self.__list_templates("default")

  def list_user_templates(self, user_id):
    return self.__list_templates("user", user_id)

  def list_project_templates(self, project_id):
    #path = PROJECTS_TEMPLATES_PATH + project_id
    #ret = self.__repo.list_objs(path)
    #return [ obj["Key"].split("/")[-1] for obj in ret if obj["Key"] != DEFAULT_TEMPLATES_PATH ]
    return self.__list_templates("project", project_id)


  def validate(self):
    # webappでのアップロード時に付けられたテンプレートオプションが本当にそのテンプレートで使えるのかを検証する (orderをベースにする？)
    # $hierarchyがあるか？とか$dateがあるか？みたいな
    # validate失敗なら例外を返してwebapp側でその旨をユーザーに伝える必要がある
    # validate成功ならs3のobject-tagとして付与して保存 (保存自体は別のメソッドが担当するが)
    pass

  def create(
      self, 
      template_type, 
      template_data, 
      parent_id, 
      name, 
      property_hierarchy,
      property_date,
      base64enc=False):
    new_id = str(uuid4())
    local_template_path = os.path.join(LOCAL_WORKSPACE_PATH, new_id)

    if base64enc:
      template_data = b64decode(template_data)
    with open(local_template_path, mode='w', encoding="utf_8_sig") as f:
      f.write(template_data)

    if template_type is "user":
      upload_path = EXCEL_TEMPLATES_PATH + "users/" + target_id
    elif template_type is "project":
      upload_path = EXCEL_TEMPLATES_PATH + "projects/" + target_id
    else:
      # TODO: 専用例外を投げるべき
      raise Exception

    exists_objects = list_user_templates(upload_path)
    if len(exists_objects) >= 5:
      # TODO: 専用例外を投げるべき
      raise Exception

    tags = self.gen_tags(name, self.user_id, property_hierarchy, property_date)
    # TODO: このテンプレートが何のオプションを使える状態なのか？をメタデータとしてタグに付与してアップロード
    # project_idかuser_idで区切ったバケットに対して保存させる(それぞれ5個まで)
    return self.__repo.put_obj(
        upload_path, 
        template_data, 
        tags
    )

  def gen_tags(self, name: str, user_id: str, hierarchy: bool, date: bool) -> str:
    # TODO: type(user|project)っているかな？
    # TODO: created_atってなくても困らないよね？updateを許さないならlast_modifyで判断可能だし、作成日時を誰かが必要とするか？という話もあるし
    # TODO: ownerも困らないよね？prefixから判断できるし
    tags = [
  	  "name={}" % name,
  	  "created_by={}" % user_id,
      "property_hierarchy={}" % str(hierarchy),
  	  "property_date={}" % str(date)
    ]
    return "&".join(tags)




  #def gen_hierarchy(self, places, place_id):
  #  hierarchy = []
  #  if place_id in self.__hierarchy_cache:
  #    hierarchy = self.__hierarchy_cache[place_id]
  #  else:
  #    for i in range(5):
  #      if place_id in places:
  #        hierarchy.insert(0, places[place_id]["name"])
  #        place_id = places[place_id]["parent_place_id"]
  #    if hierarchy:
  #      self.__hierarchy_cache.update({place_id: hierarchy})
  #  return hierarchy

  #def convert_simple_place_dict(self, places):
  #  return { place["place_id"]: {"name": place["name"], "parent_place_id": place["parent_place_id"]} for place in places }

  #def __get_photo_id_list(self, target, photo_type, all_photos=False):
  #  ret = []
  #  if all_photos:
  #    ret = [ photo_id for photo_id in target["photos"][photo_type] ]
  #  else:
  #    if isinstance(target["photos"]["adopt"][photo_type], str):
  #      ret.append(target["photos"]["adopt"][photo_type])
  #  self.logger.info("generate photo id list: %s" % str(ret))
  #  return ret

  #def __get_photo_list(self, project_id, by_name=True, needs_sort=True, reverse=False, needs_include_hierarchy=False, needs_all_photos=False, needs_date=False):
  #  targets = self.target.list(project_id)

  #  if needs_include_hierarchy:
  #    places = self.place.list(project_id)
  #    self.logger.info("get under project places: %s" % str(places))
  #    places = self.convert_simple_place_dict(places)
  #    self.logger.info("convert places to simple dict: %s" % str(places))

  #  ret = []
  #  if by_name:
  #    before_name = "施工前"
  #    after_name = "施工後"
  #  else:
  #    before_name = "before"
  #    after_name = "after"

  #  for target in targets:
  #    hierarchy = []
  #    type_name = ""
  #    if needs_include_hierarchy:
  #      hierarchy = self.gen_hierarchy(places, target["parent_place_id"])
  #      self.logger.info("generate place hierarchy names: %s" % str(hierarchy))

  #    if by_name:
  #      name = target["name"]
  #    else:
  #      name = target["target_id"]

  #    for photo_type in ["before", "after"]:
  #      for photo_id in self.__get_photo_id_list(target, photo_type, all_photos=needs_all_photos):
  #        if photo_type == "before":
  #          type_name = before_name
  #        elif photo_type == "after":
  #          type_name = after_name

  #        created_at = target["updated_at"]
  #        if needs_date:
  #          tags = self.__s3_photos.get_obj_tags(photo_id)
  #          self.logger.info("object tags: {}".format(tags))
  #          if "created_at" in tags:
  #            created_at = tags["created_at"]

  #        ret.append({
  #            "name": name,
  #            "type": type_name,
  #            "photo": photo_id,
  #            "parent_place_id": target["parent_place_id"],
  #            "created_at": created_at,
  #            "hierarchy": hierarchy
  #        })

  #  self.logger.info("result photo list in target project: {}".format(str(ret)))
  #  if needs_sort:
  #    sorted_ret = date_sort(ret, key="created_at", reverse=reverse)
  #    ret = sorted_ret
  #    self.logger.info("sorted result photo list: {}".format(str(ret)))
  #  return ret

  #def gen_zip(self, 
  #            project_id, 
  #            by_name=True, 
  #            needs_include_hierarchy=False, 
  #            needs_make_dir=True, 
  #            workspace="/tmp", 
  #            result_filename="photos_result.zip", 
  #            needs_download_url=True, 
  #            needs_date=False,
  #            char_enc="utf_8",
  #            needs_all_photos=False):

  #  local_workspace_path = os.path.join(workspace, str(uuid4()))
  #  local_result_path = os.path.join(local_workspace_path, result_filename)
  #  remote_result_path = project_id + "/" + result_filename
  #  self.logger.info("generate zip file")
  #  self.logger.info("function argument 'project_id': {}".format(project_id))
  #  self.logger.info("function argument 'by_name': {}".format(by_name))
  #  self.logger.info("function argument 'workspace': {}".format(workspace))
  #  self.logger.info("function argument 'result_filename': {}".format(result_filename))
  #  self.logger.info("function argument 'needs_download_url': {}".format(needs_download_url))
  #  self.logger.info("function argument 'needs_include_hierarchy': {}".format(needs_include_hierarchy))
  #  self.logger.info("function argument 'needs_make_dir': {}".format(needs_make_dir))
  #  self.logger.info("function argument 'needs_all_photos': {}".format(needs_all_photos))
  #  self.logger.info("function argument 'needs_date': {}".format(needs_date))
  #  self.logger.info("local_workspace_path: {}".format(local_workspace_path))
  #  self.logger.info("local_result_path: {}".format(local_result_path))
  #  self.logger.info("remote_result_path: {}".format(remote_result_path))
  #  self.logger.info("filename char encode: {}".format(char_enc))

  #  if not os.path.exists(local_workspace_path):
  #    os.mkdir(local_workspace_path)

  #  if char_enc not in ["utf_8", "shift_jis"]:
  #    char_enc = "utf_8"

  #  duplicate_names = []

  #  with ZipFile(local_result_path, 'w') as result_zip:
  #    for photo in self.__get_photo_list(project_id, by_name=by_name, needs_sort=False, needs_include_hierarchy=needs_include_hierarchy, needs_all_photos=needs_all_photos, needs_date=needs_date):
  #      self.logger.info(photo)
  #      filename = os.path.join(workspace, photo["photo"])
  #      self.logger.info("loading filename: %s" % filename)

  #      if needs_include_hierarchy and photo["hierarchy"]:
  #        if needs_make_dir:
  #          hierarchy_names = "/".join(photo["hierarchy"])
  #          inzip_filename = "{}/{}_{}".format(hierarchy_names, photo["name"], photo["type"])
  #        else:
  #          hierarchy_names = "_".join(photo["hierarchy"])
  #          inzip_filename = "{}_{}_{}".format(hierarchy_names, photo["name"], photo["type"])
  #      else:
  #        inzip_filename = "{}_{}".format(photo["name"], photo["type"])

  #      if needs_date:
  #        inzip_filename += "_" + self.iso8601_to_simple(photo["created_at"])

  #      if inzip_filename in duplicate_names:
  #        self.logger.info("detected duplicate filename. apeend random strings.")
  #        inzip_filename += "_" + self.__get_random_str()
  #      self.logger.info("write filename in zip: %s" % inzip_filename)
  #      duplicate_names.append(inzip_filename)

  #      try:
  #        self.__s3_photos.download_obj(photo["photo"], filename)
  #        # TODO: 今はshift-jisのみ。いずれ文字コードの切り替えをしたい。
  #        result_zip.write(filename=filename, arcname=inzip_filename + ".jpg")
  #      except Exception as e:
  #        self.logger.error("generate photo zip file failed... exception error occurred.")
  #        self.logger.exception(e)
  #        raise Exception
  #  self.__s3_gen.upload_obj(local_result_path, remote_result_path)

  #  ret = ""
  #  if needs_download_url:
  #    ret = self.__s3_gen.create_presigned_url(remote_result_path)
  #  else:
  #    ret = remote_result_path
  #  return ret

  #def create_download_url(self, project_id, gen_type=None):
  #  url = ""
  #  if gen_type == "zip":
  #    self.logger.info("exec start")
  #    uniq_name = str(uuid4()) + ".zip"
  #    obj_key = self.gen_zip(project_id, result_name=uniq_name)
  #    url = self.__s3_gen.create_presigned_url(obj_key)
  #    self.logger.info("generated download url: {}".format(url))

  #  return url

  #def gen_excel_doc(self, 
  #                  project_id, 
  #                  needs_sort=True, 
  #                  needs_include_hierarchy=False, 
  #                  needs_date=False,
  #                  workspace="/tmp", 
  #                  template="basic_1.xlsx", 
  #                  result_filename="photos_result.xlsx", 
  #                  needs_download_url=True):

  #  local_workspace_path = os.path.join(workspace, str(uuid4()))
  #  local_template_path = os.path.join(local_workspace_path, template)
  #  local_result_path = os.path.join(local_workspace_path, result_filename)
  #  self.logger.info("generate excel document")
  #  self.logger.info("function argument 'project_id': {}".format(project_id))
  #  self.logger.info("function argument 'needs_include_hierarchy': {}".format(needs_include_hierarchy))
  #  self.logger.info("function argument 'workspace': {}".format(workspace))
  #  self.logger.info("function argument 'template': {}".format(template))
  #  self.logger.info("function argument 'result_filename': {}".format(result_filename))
  #  self.logger.info("function argument 'needs_download_url': {}".format(needs_download_url))
  #  self.logger.info("function argument 'needs_date': {}".format(needs_date))
  #  self.logger.info("local_workspace_path: {}".format(local_workspace_path))
  #  self.logger.info("local_template_path: {}".format(local_template_path))
  #  self.logger.info("local_result_path: {}".format(local_result_path))

  #  # templateのcustom属性で判断
  #  remote_template_path = "templates/excel/defaults/{}".format(template)
  #  #if needs_custom_template:
  #  #  #remote_template_path = "templates/excel/{}/{}".format(project_id, template)
  #  #  remote_template_path = "templates/excel/defaults/{}".format(template)
  #  #else:
  #  #  remote_template_path = "templates/excel/defaults/{}".format(template)
  #  remote_result_path = project_id + "/" + result_filename

  #  if not os.path.exists(local_workspace_path):
  #    os.mkdir(local_workspace_path)

  #  photo_list = self.__get_photo_list(project_id, needs_sort=needs_sort, needs_include_hierarchy=needs_include_hierarchy, needs_date=needs_date)

  #  # TODO: photo_listが見つからなかったときに例外なげる
  #  for photo in photo_list:
  #    self.logger.info("processing target photo: {}".format(photo))
  #    filename = os.path.join(local_workspace_path, photo["photo"])
  #    self.logger.info("filename: {}".format(filename))
  #    try:
  #      self.__s3_photos.download_obj(photo["photo"], filename)

  #    except Exception as e:
  #      self.logger.info(e)
  #      return e

  #  # s3から指定のテンプレxlsxを落としてくる
  #  self.logger.info("remote_template_path: {}".format(remote_template_path))
  #  self.__s3_repo.download_obj(remote_template_path, local_template_path)
  #  if not os.path.exists(local_template_path):
  #    raise Exception
  #  self.logger.info("template download done")

  #  excel = ExcelDocGenerator(local_template_path)
  #  excel.generate(
  #    items=photo_list, 
  #    save_filename=local_result_path, 
  #    needs_include_hierarchy=needs_include_hierarchy, 
  #    needs_date=needs_date,
  #    workspace=local_workspace_path
  #  )
  #  self.__s3_gen.upload_obj(local_result_path, remote_result_path)

  #  ret = ""
  #  if needs_download_url:
  #    ret = self.__s3_gen.create_presigned_url(remote_result_path)
  #    self.logger.info("generated download url: {}".format(ret))
  #  else:
  #    ret = remote_result_path
  #  return ret

  #def __get_random_str(self):
  #   return ''.join(random.choices(string.ascii_letters + string.digits, k=4))

  #def iso8601_to_simple(self, iso8601):
  #  dt = datetime.strptime(iso8601, "%Y-%m-%dT%H:%M:%S.%f")
  #  dt_jst = dt.astimezone(timezone(timedelta(hours=+9)))
  #  return datetime.strftime(dt_jst, "%Y%m%d%H%M%S")

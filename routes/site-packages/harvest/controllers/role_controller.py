import os, sys
import json
import logging
from uuid import uuid4
from datetime import datetime

from harvest.drivers.dynamodb_driver import DynamoDbDriver

class RoleController(DynamoDbDriver):

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  user_id = None
  project_id = None

  def __init__(self, host, port):
    super().__init__(host, port, "Roles")
    super().set_partition_key("project_id")
    super().set_sort_key("user_id")

  def set_user_id(self, user_id):
    self.user_id = str(user_id)
    if self.user_id and self.project_id:
      self.__role = self.show()
      return self.__role

  def set_project_id(self, project_id):
    self.project_id = str(project_id)
    if self.user_id and self.project_id:
      self.__role = self.show()
      return self.__role
  
  def list_users(self):
    if not self.project_id:
      raise ValueError
    return super().query(self.project_id)["Items"]

  def list_projects(self):
    if not self.user_id:
      raise ValueError
    super().set_partition_key("user_id")
    super().set_sort_key(None)
    ret = super().query(self.user_id, index = "UserRolesIndex")
    super().set_partition_key("project_id")
    super().set_sort_key("user_id")
    return ret["Items"]

  def show(self, user_id=None):
    if not self.project_id:
      raise ValueError

    if not user_id:
      user_id = self.user_id

    # user_idを使って権限チェック
    ret = super().get_item(self.project_id, user_id)
    self.logger.info("fetched specified user role: {}".format(str(ret)))
    if "Item" in ret: 
      return ret["Item"]

  def create(self, role, user_id=None, project_id=None, status=None):
    if not role:
      raise ValueError

    if not user_id:
      user_id = self.user_id

    if not project_id:
      project_id = self.project_id

    if not status:
      status = "active"

    now = datetime.now().isoformat()
    return super().put_item(
      item = {
        "project_id": project_id,
        "user_id": user_id,
        "role": role,
        "status": status,
        "created_at": now,
        "updated_at": now,
        "created_by": user_id,
        "updated_by": user_id
      },
      cond_exp = 'attribute_not_exists(project_id)'
    )

  def update(self, role, user_id=None):
    if not self.project_id:
      raise ValueError

    if not user_id:
      user_id = self.user_id

    now = datetime.now().isoformat()
    return super().update_item(
        partition_key = self.project_id,
        sort_key = user_id,
        update_exp = "set #role = :role, #updated_at = :updated_at, #updated_by = :updated_by",
        exp_attr_names = {
            '#role': "role",
            "#updated_at": "updated_at",
            "#updated_by": "updated_by"
        },
        exp_attr_values={
            ":role": role,
            ":updated_at": now,
            ":updated_by": user_id

        },
        cond_exp = 'attribute_exists(user_id)'
    )

  def update_status(self, status, user_id=None):
    if not self.project_id:
      raise ValueError

    if not user_id:
      user_id = self.user_id

    now = datetime.now().isoformat()
    return super().update_item(
        partition_key = self.project_id,
        sort_key = user_id,
        update_exp = "set #status = :status, #updated_at = :updated_at, #updated_by = :updated_by",
        exp_attr_names = {
            '#status': "status",
            "#updated_at": "updated_at",
            "#updated_by": "updated_by"
        },
        exp_attr_values={
            ":status": status,
            ":updated_at": now,
            ":updated_by": user_id

        },
        cond_exp = 'attribute_exists(user_id)'
    )

  def delete(self, user_id=None):
    if not self.project_id or not self.user_id:
      raise ValueError

    if not user_id:
      user_id = self.user_id

    return super().delete_item(
      partition_key = self.project_id,
      sort_key = user_id
    )

  def delete_all(self):
    users = self.list_users()
    user_ids = [ {"project_id": self.project_id, "user_id": user["user_id"]} for user in users ]
    return super().batch_del_item(user_ids)


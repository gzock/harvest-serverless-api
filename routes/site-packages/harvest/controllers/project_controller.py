import os, sys
import json
import logging
import re
from uuid import uuid4, UUID
from datetime import datetime
from base64 import urlsafe_b64encode, urlsafe_b64decode

from harvest.drivers.dynamodb_driver import DynamoDbDriver
from harvest.drivers.cognito_driver import CognitoDriver
from harvest.controllers.role_controller import RoleController
from harvest.controllers.target_controller import TargetController
from harvest.controllers.place_controller import PlaceController

COGNITO_USER_POOL_ID="ap-northeast-1_KrEPljcrG"

class ProjectController(DynamoDbDriver):

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  def __init__(self, host, port):
    super().__init__(host, port, "Projects")
    super().set_partition_key("project_id")
    self.role = RoleController(host, port)
    self.place = PlaceController(host, port)
    self.target = TargetController(host, port)

  def set_user_id(self, user_id):
    self.user_id = str(user_id)
    self.role.set_user_id(str(user_id))

  def set_project_id(self, project_id):
    #if re.match("[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}", project_id):
    if len(project_id) == 22:
      project_id = str(UUID(bytes=urlsafe_b64decode(project_id + "==")))
    self.project_id = str(project_id)
    self.role.set_project_id(str(project_id))
    self.place.set_project_id(str(project_id))
    self.target.set_project_id(str(project_id))
  
  def list_users(self):
    if not self.project_id:
      raise ValueError

    ret = []
    cognito = CognitoDriver(COGNITO_USER_POOL_ID)
    users = self.role.list_users()
    self.logger.info("specfied project users: " + str(users))
    for user in users:
      detail = cognito.show_user(user["user_id"])[0]["Attributes"]
      self.logger.info("fetched cognito user data: " + str(detail))

      detail = { item["Name"]: item["Value"] for item in detail }
      self.logger.info("proccesing cognito user data: " + str(detail))

      if not "status" in user:
        user.update({"status": "active"})
      ret.append(
        {
          "user_id": user["user_id"],
          "username": detail["preferred_username"],
          "email": detail["email"],
          "role": user["role"],
          "status": user["status"]
        }
      )
      self.logger.info("users list: " + str(detail))
    return ret

  def show_user(self, user_id):
    if not self.project_id:
      raise ValueError

    ret = ""
    detail = {}
    cognito = CognitoDriver(COGNITO_USER_POOL_ID)
    user = self.role.show(user_id)

    if not user:
      # TODO: カスタム例外なげる
      raise ValueError

    detail = cognito.show_user(user_id)[0]["Attributes"]
    self.logger.info("fetched cognito user data: " + str(detail))
    detail = { item["Name"]: item["Value"] for item in detail }
    self.logger.info("proccesing cognito user data: " + str(detail))

    if not detail:
      # TODO: カスタム例外なげる
      raise ValueError

    ret = {
      "user_id": user_id,
      "username": detail["preferred_username"],
      "email": detail["email"],
      "role": user["role"]
    }
    self.logger.info("user detail info: " + str(ret))
    return ret

  def list_project_roles(self):
    if not self.user_id:
      raise ValueError

    return self.role.list_projects()
    
  def list_project_ids(self):
    if not self.user_id:
      raise ValueError

    return [ item["project_id"] for item in self.list_project_roles() ]
    
  def list_projects(self):
    if not self.user_id:
      raise ValueError

    ret = []
    roles = self.list_project_roles()
    self.logger.info("project roles: " + str(roles))
    keys = [ {"project_id": role["project_id"]} for role in roles ]

    if keys:
      # TODO: 10個以上のプロジェクトを持つ時の想定をする
      projects = self.dynamodb.batch_get_item(
        RequestItems = {
          "Projects": {
            "Keys": keys,
            "ConsistentRead": False
          }
        }
      )["Responses"]["Projects"]
      self.logger.info("projects: " + str(projects))

      for project in projects:
        for role in roles:
          if project["project_id"] == role["project_id"]:
            project.update({"role": role["role"]})
            project.update({"project_code": self.gen_project_code(project["project_id"])})
            ret.append(project)

      self.logger.info("return for projects with role: " + str(ret))
    return ret

  def show(self):
    if not self.user_id or not self.project_id:
      raise ValueError
    # user_idを使って権限チェック
    return super().get_item(self.project_id)

  def gen_project_code(self, project_id):
    if not project_id:
      project_id = self.project_id

    self.logger.info("specified project_id: " + project_id)
    project_code = urlsafe_b64encode(UUID(project_id).bytes).decode('ASCII').rstrip('=')
    self.logger.info("convert project_id to project_code: " + project_code)
    return project_code

  def join_user(self, user_id=None):
    if not self.project_id:
      raise ValueError
    if not user_id:
      user_id = self.user_id
    return self.role.create(
        "worker", 
        user_id = user_id,
        project_id = self.project_id, 
        status = "request"
    )

  def accept_user(self, user_id=None):
    if not self.project_id:
      raise ValueError
    if not user_id:
      user_id = self.user_id
    return self.role.update_status(
        status = "active",
        user_id = user_id
    )

  def reject_user(self, user_id=None):
    if not self.user_id or not self.project_id:
      raise ValueError
    if not user_id:
      user_id = self.user_id
    return self.role.update_status(
        status = "reject",
        user_id = user_id
    )

  def delete_user(self, user_id=None):
    if not self.user_id or not self.project_id:
      raise ValueError
    if not user_id:
      user_id = self.user_id
    return self.role.delete(user_id)

  def update_role(self, role, user_id=None):
    if not self.project_id:
      raise ValueError
    if not user_id:
      user_id = self.user_id
    return self.role.update(role, user_id)

  def create(self, name, start_on, complete_on):
    if not self.user_id or not name:
      raise ValueError

    # そのユーザにpj作成権限があるかどうかを確認
    new_id = str(uuid4())
    now = datetime.now().isoformat()

    ret = super().put_item(
      item = {
        "project_id": new_id,
        "name": str(name),
        "created_at": now,
        "updated_at": now,
        "start_on": start_on,
        "complete_on": complete_on
      }
    )
    self.logger.info(ret)

    # TODO: project作成が失敗した時の処理を考える＠というかトランザクション？
    role_ret = self.role.create("owner", project_id = new_id)
    self.role.set_project_id(new_id)
    return ret


  def update_name(self, name):
    if not self.user_id or not self.project_id:
      raise ValueError

    # user_idを使って権限チェック
    now = datetime.now().isoformat()
    return super().update_item(
        partition_key = self.project_id,
        update_exp = "set #name = :name, #updated_at = :updated_at",
        exp_attr_names = {
            '#name': "name",
            "#updated_at": "updated_at"
        },
        exp_attr_values={
            ":name": name,
            ":updated_at": now

        },
        cond_exp = 'attribute_exists(project_id)'
    )

  def update_users(self, users):
    if not self.user_id or not self.project_id:
      raise ValueError

    if isinstance(users, list):
      users = "#".join(users)

    # user_idを使って権限チェック
    now = datetime.now().isoformat()
    return super().update_item(
        partition_key = self.project_id,
        update_exp = "set #users = :users, #updated_at = :updated_at",
        exp_attr_names = {
            '#users': "users",
            "#updated_at": "updated_at"
        },
        exp_attr_values={
            ':users': users,
            ":updated_at": now
        },
        cond_exp = 'attribute_exists(project_id)'
    )

  def delete(self):
    if not self.user_id or not self.project_id:
      raise ValueError
    # user_idを使って権限チェック

    # TODO: projectの削除が失敗した時の処理を考える＠というかトランザクション？
    self.role.delete_all()
    ret = super().delete_item(self.project_id)
    self.place.delete_all()
    self.target.delete_all()

    return ret

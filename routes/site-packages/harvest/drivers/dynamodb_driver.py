import logging
import boto3
from boto3.dynamodb.conditions import Key, Attr

class DynamoDbDriver():

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  def __init__(self, host, port, table_name):
    #if not host or not port:
    #  raise ValueError
    self.__dynamo_host = host
    self.__dynamo_port = port
    self.logger.info("connecting dynamo host: {}, port: {}".format(host, port))

    try:
      self.dynamodb, self.client = self.__connect(self.__dynamo_host, self.__dynamo_port)
      self.__table = self.dynamodb.Table(table_name)
      #self.client = boto3.client('dynamodb', region_name='ap-northeast-1', endpoint_url = 'http://' + host + ':' + port)
    except Exception as e:
      raise e

  def __connect(self, host, port):
    if host and port:
      resource = boto3.resource(
          "dynamodb",
          region_name = "ap-northeast-1",
          endpoint_url = 'http://' + host + ':' + port
      )
      client = boto3.client(
          'dynamodb', 
          region_name='ap-northeast-1', 
          endpoint_url = 'http://' + host + ':' + port
      )
    else:
      resource = boto3.resource(
          "dynamodb",
          region_name = "ap-northeast-1"
      )
      client = boto3.client(
          'dynamodb', 
          region_name='ap-northeast-1'
      )

    return resource, client

  def set_partition_key(self, key):
    self.__partition_key = key

  def set_sort_key(self, key):
    self.__sort_key = key

  def get_item(self, partition_key, sort_key = None):
    if partition_key and not sort_key:
      keys = {
           self.__partition_key: partition_key
      }
    elif partition_key and sort_key:
      keys = {
           self.__partition_key: partition_key,
           self.__sort_key: sort_key,
      }
    else:
      raise ValueError

    return self.__table.get_item(Key = keys)

  def put_item(self, item, cond_exp = None):
    if not isinstance(item, dict):
        raise TypeError
    if cond_exp:
      return self.__table.put_item(
          Item = item, 
          ConditionExpression = cond_exp,
          ReturnValues = "ALL_OLD"
      )
    else:
      return self.__table.put_item(
          Item = item, 
          ReturnValues = "ALL_OLD"
      )

  def batch_put_item(self, items):
    results = []
    with self.__table.batch_writer() as batch:
      for item in items:
        ret = batch.put_item(
            Item=item
        )
        results.append(ret)
    return results

  def batch_del_item(self, keys):
    results = []
    with self.__table.batch_writer() as batch:
      for key in keys:
        ret = batch.delete_item(
            Key=key
        )
        results.append(ret)
    return results

  def scan(self):
    return self.__table.scan()

  def query(self, partition_key, sort_key = None, index = None, begins_with = False):
    if partition_key and not sort_key:
      cond_exp = Key(self.__partition_key).eq(partition_key)

      if index:
        return self.__table.query(
            IndexName = index,
            KeyConditionExpression = cond_exp
        )
      else:
        return self.__table.query(
            KeyConditionExpression = cond_exp
        )
    elif partition_key and sort_key:
      if begins_with:
        cond_exp = Key(self.__partition_key).eq(partition_key) & Key(self.__sort_key).begins_with(sort_key)
      else:
        cond_exp = Key(self.__partition_key).eq(partition_key) & Key(self.__sort_key).eq(sort_key)

      if index:
        return self.__table.query(
            IndexName = index,
            KeyConditionExpression = cond_exp
        )
      else:
        return self.__table.query(
            KeyConditionExpression = cond_exp
        )
    else:
      raise ValueError

  def update_item(
      self, 
      partition_key, 
      update_exp, 
      sort_key = None, 
      exp_attr_names = None, 
      exp_attr_values = None, 
      cond_exp = None,
      ret_value="UPDATED_NEW"):

    if partition_key and not sort_key:
      keys = {
           self.__partition_key: partition_key
      }
    elif partition_key and sort_key:
      keys = {
           self.__partition_key: partition_key,
           self.__sort_key: sort_key
      }
    else:
      raise ValueError

    return self.__table.update_item(
        Key = keys,
        UpdateExpression = update_exp,
        ExpressionAttributeNames = exp_attr_names,
        ExpressionAttributeValues = exp_attr_values,
        ConditionExpression = cond_exp,
        ReturnValues = ret_value
    )

  def delete_item(self, partition_key, sort_key = None):

    if partition_key and not sort_key:
      keys = {
           self.__partition_key: partition_key
      }
    elif partition_key and sort_key:
      keys = {
           self.__partition_key: partition_key,
           self.__sort_key: sort_key
      }
    else:
      raise ValueError

    return self.__table.delete_item(
        Key = keys, 
        ConditionExpression = 'attribute_exists({})'.format(self.__partition_key)
    )

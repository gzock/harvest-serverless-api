import os
import logging
from uuid import uuid4
from datetime import datetime, timedelta, timezone
import openpyxl
from openpyxl.utils import get_column_letter, column_index_from_string, rows_from_range, cols_from_range
from openpyxl.styles.fonts import Font
from openpyxl.worksheet.pagebreak import Break
from openpyxl.cell.cell import Cell, MergedCell
#from openpyxl.utils.cell import coordinate_from_string, column_index_from_string
from PIL import Image

from copy import copy

class ExcelDocGenerator():

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  def __init__(self, workbook=None, worksheet=None):
    if workbook:
      self.load_workbook(workbook)
      self.active_worksheet(worksheet)

  def load_workbook(self, filename):
    self.logger.info("loading filename: %s" % filename)
    self.wb = openpyxl.load_workbook(filename=filename, read_only=False, keep_vba=False, data_only=True, keep_links=False)
    self.logger.info("loading done")

  def active_worksheet(self, sheet_name=0):
    if self.wb:
      if sheet_name:
        self.ws = self.wb[sheet_name]
      else:
        self.ws = self.wb.active
  
  def copy_cells(self, src_row_min, src_row_max, dst_row_base, count):
    next_base = 0
    for c in range(count):
      for index, row in enumerate(self.ws.iter_rows(min_row=src_row_min, max_row=src_row_max)):
        for cell in row:
          self.ws.cell(row=dst_row_base + index, column=cell.column).value = copy(cell.value)
          self.ws.cell(row=dst_row_base + index, column=cell.column).style = copy(cell.style)
          self.ws.cell(row=dst_row_base + index, column=cell.column).fill = copy(cell.fill)
          self.ws.cell(row=dst_row_base + index, column=cell.column).border = copy(cell.border)
          self.ws.cell(row=dst_row_base + index, column=cell.column).font = copy(cell.font)
          self.ws.cell(row=dst_row_base + index, column=cell.column).alignment = copy(cell.alignment)
          self.ws.row_dimensions[dst_row_base + index].height = copy(self.ws.row_dimensions[cell.row].height)
      dst_row_base = dst_row_base + index + 1

  def get_merged_cells(self):
    if "merged_cells_ranges" not in locals():
      self.merged_cells_ranges = self.ws.merged_cells.ranges
    return self.merged_cells_ranges

  def get_merged_cell(self, cell):
    for cell_range in self.get_merged_cells():
      for row in list(rows_from_range(str(cell_range))):
        if cell.coordinate in row:
          return cell_range

  def get_cell_height(self, cell):
    cell_range = self.get_merged_cell(cell)
    if cell_range:
      height = 0
      for row in list(rows_from_range(str(cell_range))):
        height += self.ws.row_dimensions[self.ws[row[0]].row].height
      else:
        return round(height)
    else:
      return round(self.ws.row_dimensions[cell.row].height)

  def get_cell_width(self, cell):
    cell_range = self.get_merged_cell(cell)
    if cell_range:
      width = 0
      for col in list(cols_from_range(str(cell_range))):
        width += self.ws.column_dimensions[get_column_letter(self.ws[col[0]].column)].width
      else:
        return round(width)
    else:
      return round(self.ws.column_dimensions[get_column_letter(cell.column)].width)

  def get_cell_height_px(self, cell):
    return round(self.get_cell_height(cell) * 1.33)

  def get_cell_width_px(self, cell):
    return round(self.get_cell_width(cell) * 8.08)

  def save(self, filename):
    return self.wb.save(filename)

  def open_image(self, filename):
    return  Image.open(filename)

  def save_image(self, img, filename):
    return img.save(filename)

  def resize_image(self, img, width, height):
    return img.resize((width, height),Image.NEAREST)

  def resize_image_to_cell(self, img, cell):
    ratio = 1
    width = img.width
    height = img.height

    font = Font(
      name='Arial',
      sz=10,
    )
    cell.font = font

    cellHeight = self.get_cell_height_px(cell)
    cellWidth = self.get_cell_width_px(cell)
    self.logger.info("target cell width, height: {}, {}".format(cellWidth, cellHeight))

    if width > cellWidth:
      ratio = cellWidth / width
      width *= ratio
      height *= ratio

    if height > cellHeight:
      ratio = cellHeight / height
      height *= ratio
      width *= ratio

    self.logger.info("needs resize cell width, height: {}, {}".format(width, height))
    return self.resize_image(img, round(width), round(height))

  def add_image(self, filename, cell, adjust=True, workspace="/tmp"):
    self.logger.info("add image({}) to cell({})".format(filename, cell))
    tmp_resized_img = os.path.join(workspace, str(uuid4()) + ".jpg")
    if adjust:
      img = Image.open(filename)
      img = self.resize_image_to_cell(img, cell)
      self.save_image(img, tmp_resized_img)
      img = openpyxl.drawing.image.Image(tmp_resized_img)
    else:
      img = openpyxl.drawing.image.Image(filename)
    cell.value = ""

    anchor = get_column_letter(cell.column) + str(cell.row)
    return self.ws.add_image(img, anchor)

  def add_value(self, value, cell):
    if value:
      self.logger.info("add value({}) to cell({})".format(value, cell))
    cell.value = value
    return cell

  def get_page_breaks(self, row_num_only=False):
    print("---")
    print(self.ws.page_breaks)
    print("---")
    if len(self.ws.page_breaks) == 0:
      return []

    if row_num_only:
      return [ item.id for item in self.ws.page_breaks[0].brk ] 
    else:
      return self.ws.page_breaks[0].brk

  def add_page_break(self, cell=None, row=None):
    if cell:
      page_break = Break(id=cell.row)
    else:
      page_break = Break(id=row)
    self.ws.page_breaks[0].brk.append(page_break)

  def delete_page_break(self, row):
    for i, brk in enumerate(self.ws.page_breaks[0].brk):
      if brk.id == row:
        del self.ws.page_breaks[0].brk[i]

  def collect_cells(self, value):
    cells = []
    for row in self.ws:
      for cell in row:
        if cell.value == value:
          cells.append(cell)
    else:
      return cells

  def aggregate_cell_values(self, max_cnt):
    cell_values = {}
    pass_cnt = 0

    for row in self.ws:
      for cell in row:
        if cell.value:
          if cell.value not in cell_values:
            cell_values[cell.value] = []
          elif len(cell_values[cell.value]) > max_cnt:
            pass_cnt += 1
            continue
          cell_values[cell.value].append(cell)
      if pass_cnt > 50:
        break
    return cell_values

  def add_each_images(self, images, cells, clean=True):
    for image in images:
      self.add_image(image, cells.pop(0))
    if clean:
      for cell in cells:
        self.add_value("", cell)
    return cells[0]

  def add_each_values(self, values, cells, clean=True):
    for value in values:
      self.add_value(value, cells.pop(0))
    if clean:
      for cell in cells:
        self.add_value("", cell)
    return cells[0]

  def has_hierarchy(self):
    if "{hierarchy}" in self.aggregate_cell_values(1):
      return True
    else:
      return False

  def has_date(self):
    if "{date}" in self.aggregate_cell_values(1):
      return True
    else:
      return False
    
  def generate(self, title, items, save_filename, needs_include_hierarchy=False, needs_date=False, workspace="/tmp"):
    self.logger.info("photo list length: {}".format(len(items) + 1))

    # 改ページを探す
    page_breaks = self.get_page_breaks(row_num_only=True)
    copy_ranges = {"src_row_min": 1, "src_row_max": 2, "dst_row_base": 2}

    # 1pか2pか判断
    # コピーすべきcell-rangeを計算
    if len(page_breaks) == 1:
      copy_ranges["src_row_max"] = page_breaks[0]
      copy_ranges["dst_row_base"] = page_breaks[0] + 1
    elif len(page_breaks) == 2:
      copy_ranges["src_row_min"] = page_breaks[0]
      copy_ranges["src_row_max"] = page_breaks[1]
      copy_ranges["dst_row_base"] = page_breaks[1] + 1
    else:
      # TODO: 専用例外
      raise Exception

    # 渡されたphoto-listの数分、↑のcell-rangeをコピー
    self.copy_cells(**copy_ranges, count=len(items))
    # photoとかnameとかの数が合っているかを計算
    # pass

    # 既存の改ページを除去
    for i in page_breaks:
      excel.delete_page_break(i)

    # 後は同じ処理


    cell_values = self.aggregate_cell_values(len(items))
    #self.logger.info("aggregated cell values: {}".format(cell_values[:500]))
    # TODO: key checkが必要なはず
    if "{title}" in cell_values:
      title_cell = cell_values["{title}"][0]
    image_cells = cell_values["{photo}"]
    type_cells = cell_values["{type}"]
    name_cells = cell_values["{name}"]

    if "{index}" in cell_values:
      index_cells = cell_values["{index}"]

    if needs_include_hierarchy and "{hierarchy}" in cell_values:
      hierarchies_cells = cell_values["{hierarchy}"]
    if needs_date and "{date}" in cell_values:
      date_cells = cell_values["{date}"]
    
    images = []
    types = []
    names = []
    dates = []
    hierarchies = []
    for item in items:
      images.append(os.path.join(workspace, item["photo"]))
      types.append(item["type"])
      names.append(item["name"])
      if needs_include_hierarchy and "{hierarchy}" in cell_values:
        hierarchies.append(" / ".join(item["hierarchy"]))
      if needs_date and "{date}" in cell_values:
        dates.append(self.iso8601_to_simple(item["created_at"]))
    indexs = list(range(1, len(names) + 1))

    self.logger.info("images: {}".format(images))
    cells = []
    if "title_cell" in locals():
      self.add_value(title, title_cell)
    cells.append(self.add_each_images(images, image_cells, False))
    cells.append(self.add_each_values(types, type_cells, False))
    cells.append(self.add_each_values(names, name_cells, False))

    if "{index}" in cell_values:
      cells.append(self.add_each_values(indexs, index_cells, False))
    if needs_include_hierarchy and "hierarchies_cells" in locals():
      cells.append(self.add_each_values(hierarchies, hierarchies_cells, False))
    if needs_date and "date_cells" in locals():
      cells.append(self.add_each_values(dates, date_cells, False))

    last_col_cell = max(cells, key=lambda x:x.column)
    last_row_cell = min(cells, key=lambda x:x.row)

    self.logger.info("last_col_cell: {}".format(last_col_cell))
    self.logger.info("last_row_cell: {}".format(last_row_cell))

    #last_col = coordinate_from_string(last_col_cell)[0]
    #last_row = coordinate_from_string(last_row_cell)[1]

    #self.logger.info("last_col: {}".format(last_col))
    #self.logger.info("last_row: {}".format(last_row))

    # 印刷エリア設定
    # これがないと既存の改ページに沿った印刷エリア = 最小限領域になってしまうので必須処理
    self.ws.print_area = "A1:%s%s" % (last_col_cell.column, last_row)
    self.logger.info("setting print_are: {}".format(self.ws.print_area))

    # 印刷設定をするのでわざわざ改ページ設定は不要
    #self.add_page_break(cell=last_cell)

    # 無駄はないはずなので、これは不要
    #self.ws.delete_rows(last_cell.row, 2000)

    # TODO: header / print titleの設定
    return self.save(save_filename)

  #def generate(self, title, items, save_filename, needs_include_hierarchy=False, needs_date=False, workspace="/tmp"):
  #  self.logger.info("photo list length: {}".format(len(items) + 1))

  #  cell_values = self.aggregate_cell_values(len(items))
  #  #self.logger.info("aggregated cell values: {}".format(cell_values[:500]))
  #  # TODO: key checkが必要なはず
  #  if "{title}" in cell_values:
  #    title_cell = cell_values["{title}"][0]
  #  image_cells = cell_values["{photo}"]
  #  type_cells = cell_values["{type}"]
  #  name_cells = cell_values["{name}"]

  #  if "{index}" in cell_values:
  #    index_cells = cell_values["{index}"]

  #  if needs_include_hierarchy and "{hierarchy}" in cell_values:
  #    hierarchies_cells = cell_values["{hierarchy}"]
  #  if needs_date and "{date}" in cell_values:
  #    date_cells = cell_values["{date}"]
  #  
  #  images = []
  #  types = []
  #  names = []
  #  dates = []
  #  hierarchies = []
  #  for item in items:
  #    images.append(os.path.join(workspace, item["photo"]))
  #    types.append(item["type"])
  #    names.append(item["name"])
  #    if needs_include_hierarchy and "{hierarchy}" in cell_values:
  #      hierarchies.append(" / ".join(item["hierarchy"]))
  #    if needs_date and "{date}" in cell_values:
  #      dates.append(self.iso8601_to_simple(item["created_at"]))
  #  indexs = list(range(1, len(names) + 1))

  #  self.logger.info("images: {}".format(images))
  #  cells = []
  #  if "title_cell" in locals():
  #    self.add_value(title, title_cell)
  #  cells.append(self.add_each_images(images, image_cells, False))
  #  cells.append(self.add_each_values(types, type_cells, False))
  #  cells.append(self.add_each_values(names, name_cells, False))

  #  if "{index}" in cell_values:
  #    cells.append(self.add_each_values(indexs, index_cells, False))
  #  if needs_include_hierarchy and "hierarchies_cells" in locals():
  #    cells.append(self.add_each_values(hierarchies, hierarchies_cells, False))
  #  if needs_date and "date_cells" in locals():
  #    cells.append(self.add_each_values(dates, date_cells, False))
  #  last_cell = min(cells, key=lambda x:x.row)
  #  self.logger.info("last_cell: {}".format(last_cell))
  #  self.add_page_break(cell=last_cell)
  #  self.ws.delete_rows(last_cell.row, 2000)
  #  return self.save(save_filename)

  def iso8601_to_simple(self, iso8601):
    dt = datetime.strptime(iso8601, '%Y-%m-%dT%H:%M:%S.%f')
    dt_jst = dt.astimezone(timezone(timedelta(hours=+9)))
    return datetime.strftime(dt_jst, "%Y/%m/%d")

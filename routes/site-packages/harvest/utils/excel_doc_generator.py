import os
import logging
from uuid import uuid4
from datetime import datetime
import openpyxl
from openpyxl.utils import get_column_letter, column_index_from_string, rows_from_range, cols_from_range
from openpyxl.styles.fonts import Font
from openpyxl.worksheet.pagebreak import Break
from openpyxl.cell.cell import Cell, MergedCell
from PIL import Image

class ExcelDocGenerator():

  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  def __init__(self, workbook=None, worksheet=None):
    if workbook:
      self.load_workbook(workbook)
      self.active_worksheet(worksheet)

  def load_workbook(self, filename):
    self.wb = openpyxl.load_workbook(filename)

  def active_worksheet(self, sheet_name=0):
    if self.wb:
      if sheet_name:
        self.ws = self.wb[sheet_name]
      else:
        self.ws = self.wb.active

  def get_merged_cells(self):
    if "merged_cells_ranges" not in locals():
      self.merged_cells_ranges = self.ws.merged_cells.ranges
    return self.merged_cells_ranges

  def get_merged_cell(self, cell):
    for cell_range in self.get_merged_cells():
      for row in list(rows_from_range(str(cell_range))):
        if cell.coordinate in row:
          return cell_range

  def get_cell_height(self, cell):
    cell_range = self.get_merged_cell(cell)
    if cell_range:
      height = 0
      for row in list(rows_from_range(str(cell_range))):
        height += self.ws.row_dimensions[self.ws[row[0]].row].height
      else:
        return round(height)
    else:
      return round(self.ws.row_dimensions[cell.row].height)

  def get_cell_width(self, cell):
    cell_range = self.get_merged_cell(cell)
    if cell_range:
      width = 0
      for col in list(cols_from_range(str(cell_range))):
        width += self.ws.column_dimensions[get_column_letter(self.ws[col[0]].column)].width
      else:
        return round(width)
    else:
      return round(self.ws.column_dimensions[get_column_letter(cell.column)].width)

  def get_cell_height_px(self, cell):
    return round(self.get_cell_height(cell) * 1.33)

  def get_cell_width_px(self, cell):
    return round(self.get_cell_width(cell) * 8.08)

  def save(self, filename):
    return self.wb.save(filename)

  def open_image(self, filename):
    return  Image.open(filename)

  def save_image(self, img, filename):
    return img.save(filename)

  def resize_image(self, img, width, height):
    return img.resize((width, height),Image.NEAREST)

  def resize_image_to_cell(self, img, cell):
    ratio = 1
    width = img.width
    height = img.height

    font = Font(
      name='Arial',
      sz=10,
    )
    cell.font = font

    cellHeight = self.get_cell_height_px(cell)
    cellWidth = self.get_cell_width_px(cell)
    self.logger.info("target cell width, height: {}, {}".format(cellWidth, cellHeight))

    if width > cellWidth:
      ratio = cellWidth / width
      width *= ratio
      height *= ratio

    if height > cellHeight:
      ratio = cellHeight / height
      height *= ratio
      width *= ratio

    self.logger.info("needs resize cell width, height: {}, {}".format(width, height))
    return self.resize_image(img, round(width), round(height))

  def add_image(self, filename, cell, adjust=True, workspace="/tmp"):
    self.logger.info("add image({}) to cell({})".format(filename, cell))
    tmp_resized_img = os.path.join(workspace, str(uuid4()) + ".jpg")
    if adjust:
      img = Image.open(filename)
      img = self.resize_image_to_cell(img, cell)
      self.save_image(img, tmp_resized_img)
      img = openpyxl.drawing.image.Image(tmp_resized_img)
    else:
      img = openpyxl.drawing.image.Image(filename)
    cell.value = ""

    anchor = get_column_letter(cell.column) + str(cell.row)
    return self.ws.add_image(img, anchor)

  def add_value(self, value, cell):
    if value:
      self.logger.info("add value({}) to cell({})".format(value, cell))
    cell.value = value
    return cell

  def add_page_break(self, cell=None, row=None):
    if cell:
      page_break = Break(id=cell.row)
    else:
      page_break = Break(id=row)
    self.ws.page_breaks.append(page_break)

  def collect_cells(self, value):
    cells = []
    for row in self.ws:
      for cell in row:
        if cell.value == value:
          cells.append(cell)
    else:
      return cells

  def aggregate_cell_values(self):
    cell_values = {}
    for row in self.ws:
      for cell in row:
        if cell.value:
          if cell.value not in cell_values:
            cell_values[cell.value] = []
          cell_values[cell.value].append(cell)
    return cell_values

  def add_each_images(self, images, cells, clean=True):
    for image in images:
      self.add_image(image, cells.pop(0))
    if clean:
      for cell in cells:
        self.add_value("", cell)
    return cells[0]

  def add_each_values(self, values, cells, clean=True):
    for value in values:
      self.add_value(value, cells.pop(0))
    if clean:
      for cell in cells:
        self.add_value("", cell)
    return cells[0]

  def generate(self, items, save_filename, needs_include_hierarchy=False, needs_date=False, workspace="/tmp"):
    cell_values = self.aggregate_cell_values()
    # TODO: key checkが必要なはず
    index_cells = cell_values["{index}"]
    image_cells = cell_values["{photo}"]
    type_cells = cell_values["{type}"]
    name_cells = cell_values["{name}"]

    if needs_include_hierarchy:
      hierarchies_cells = cell_values["{hierarchy}"]
    if needs_date:
      date_cells = cell_values["{date}"]
    
    images = []
    types = []
    names = []
    dates = []
    hierarchies = []
    for item in items:
      images.append(os.path.join(workspace, item["photo"]))
      types.append(item["type"])
      names.append(item["name"])
      dates.append(self.iso8601_to_simple(item["created_at"]))
      hierarchies.append(" / ".join(item["hierarchy"]))
    indexs = list(range(1, len(names) + 1))

    self.logger.info("images: {}".format(images))
    cells = []
    cells.append(self.add_each_values(indexs, index_cells))
    cells.append(self.add_each_images(images, image_cells))
    cells.append(self.add_each_values(types, type_cells))
    cells.append(self.add_each_values(names, name_cells))
    if needs_include_hierarchy and hierarchies_cells:
      cells.append(self.add_each_values(hierarchies, hierarchies_cells))
    if needs_date and date_cells:
      cells.append(self.add_each_values(dates, date_cells))
    last_cell = max(cells, key=lambda x:x.row)
    self.logger.info("last_cell: {}".format(last_cell))
    self.add_page_break(cell=last_cell)
    return self.save(save_filename)

  def iso8601_to_simple(self, iso8601):
    dt = datetime.strptime(iso8601, '%Y-%m-%dT%H:%M:%S.%f')
    return dt.strftime("%Y/%m/%d")


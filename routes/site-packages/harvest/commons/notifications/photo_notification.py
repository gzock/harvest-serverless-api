from harvest.commons.notifications.base_notification import BaseNotification

class PhotoNotification(BaseNotification):
  shot_before_photo = "{project_name}: {user_name}さんによって{name}の施工前写真が撮影されました"
  shot_after_photo = "{project_name}: {user_name}さんによって{name}の施工後写真が撮影されました"
  update_adopt_before_photo = "{project_name}: {user_name}さんによって{name}の施工前採用写真が変更されました"
  update_adopt_after_photo = "{project_name}: {user_name}さんによって{name}の施工後採用写真が変更されました"
  delete_before_photo = "{project_name}: {user_name}さんによって{name}の施工前写真が削除されました"
  delete_after_photo = "{project_name}: {user_name}さんによって{name}の施工後写真が削除されました"

  def __init__(self, stream_record, host, port):
    super().set_record_type("撮影対象")
    super().__init__(stream_record, host, port)

  def select_message(self):
    if self.is_insert_event:
      pass

    elif self.is_modify_event:
      print(self.old_record["photos"])
      print(self.record["photos"])
      print(self.old_record["photos"]["adopt"])
      print(self.record["photos"]["adopt"])
      if len(self.old_record["photos"]["before"]["L"]) < len(self.record["photos"]["before"]["L"]):
        self.message = self.shot_before_photo

      elif len(self.old_record["photos"]["after"]["L"]) < len(self.record["photos"]["after"]["L"]):
        self.message = self.shot_after_photo

      elif len(self.old_record["photos"]["before"]["L"]) > len(self.record["photos"]["before"]["L"]):
        self.message = self.delete_before_photo

      elif len(self.old_record["photos"]["after"]["L"]) > len(self.record["photos"]["after"]["L"]):
        self.message = self.delete_after_photo

      elif self.old_record["photos"]["adopt"]["M"]["before"] != self.record["photos"]["adopt"]["M"]["before"]:
        self.message = self.update_adopt_before_photo

      elif self.old_record["photos"]["adopt"]["M"]["after"] != self.record["photos"]["adopt"]["M"]["after"]:
        self.message = self.update_adopt_after_photo

    elif self.is_remove_event:
      pass

    return self.message

  def generate(self):
    self.needs_strings_dict.update(
      {
        "name": self.record["name"]
      }
    )
    return super().generate()

from datetime import datetime
from dateutil.relativedelta import relativedelta
from calendar import monthrange
from math import floor
import logging

from harvest.controllers.billing_controller import BillingController

PRICE_PER_ACCOUNT = 500
TAX=1.10
CLOSING_DATE=25

class Billing():
  logger = logging.getLogger(__name__)
  logger.addHandler(logging.NullHandler())
  logger.setLevel(logging.DEBUG)

  users = None

  def __init__(self, host, port, user_id=None):
    self.billing = BillingController(host, port)
    if user_id:
      self.billing.set_user_id(user_id)

  def set_users(self, users):
    self.users = users

  def show(self, user_id=None):
    if not user_id:
      user_id = self.user_id

    billing_data = self.billing.show(user_id)

    ret = {
      "price": billing_data["history"][-1]["price"],
      "closed_on": self.get_closing_date(),
      "billed_on": self.get_cycle(),
      "status": self.get_status()
    }
    ret.update(billing_data)
    return ret

  def calc_price(self, account_cnt, month=None, raw=False):
    if raw:
      price = account_cnt * PRICE_PER_ACCOUNT
    else:
      price = floor(account_cnt * PRICE_PER_ACCOUNT * TAX)
    return price

  #TODO: 月指定での請求日を求められる機能があったほうが良いかも
  def get_cycle(self, needs_isoformat=True):
    now = datetime.now()
    if CLOSING_DATE < now.day:
      now = now + relativedelta(months=1)

    last_day = monthrange(now.year, now.month)[1]
    if needs_isoformat:
      ret = now.replace(day=last_day, hour=0, minute=0, second=0, microsecond=0).isoformat()
    else:
      ret = now.replace(day=last_day, hour=0, minute=0, second=0, microsecond=0)
    return ret

  def get_closing_date(self, needs_isoformat=True):
    now = datetime.now()
    if CLOSING_DATE < now.day:
      now = now + relativedelta(months=1)

    if needs_isoformat:
      ret = now.replace(day=CLOSING_DATE, hour=0, minute=0, second=0, microsecond=0).isoformat()
    else:
      ret = now.replace(day=CLOSING_DATE, hour=0, minute=0, second=0, microsecond=0)
    return ret

  def get_status(self):
    status = "pending"
    now = datetime.now()
    closing_date = self.get_closing_date(needs_isoformat=False)
    if now >= closing_date:
      status = "fixed"
    return status

  # 最初の請求レコードを作成
  def create(self, user_id=None):
    if not user_id:
      user_id = self.user_id
    if self.users:
      users_count = len(self.users)
    else:
      # TODO: 専用例外を投げるべき
      raise Exception

    should_write = True
    histories = self.billing.list_history(user_id)

    invoice_date = datetime.strptime(self.get_cycle(), '%Y-%m-%dT%H:%M:%S')
    closing_date = datetime.strptime(self.get_closing_date(), '%Y-%m-%dT%H:%M:%S')
    start_date = closing_date - relativedelta(months=1) + relativedelta(days=1)

    for history in histories:
      if history["invoice_date"] == invoice_date.strftime('%Y/%m/%d'):
        self.logger.info("current users count: %s, last recorded users count: %s" % (users_count, history["users_count"]))
        if users_count <= history["users_count"]:
          self.logger.info("users count was decremented or no changed. no need to update bill.")
          should_write = False
        else:
          self.logger.info("users count was incremented. need to update bill.")
          context = "history_" + invoice_date.strftime('%Y%m')
          invoice_number = history["invoice_number"]
        break
    else:
      context = "history_" + invoice_date.strftime('%Y%m')
      invoice_number = len(histories) + 1

    if should_write:
      ret = self.billing.create(
          context=context,
          period="%s-%s" % (start_date.strftime("%Y/%m/%d"), closing_date.strftime("%Y/%m/%d")), 
          invoice_date=invoice_date.strftime("%Y/%m/%d"), 
          invoice_number=invoice_number, 
          user_id=user_id, 
          raw_price=self.calc_price(users_count, raw=True), 
          tax=TAX, 
          users_count=users_count
      )
    else:
      ret =  {"ResponseMetadata": {"HTTPStatusCode": 200}}
    return ret

  # アカウント作成の際にusers_countやpriceを再計算して既存レコードを更新
  def update(self, event, user_id):
    if not user_id:
      user_id = self.user_id

    if event not in ["create_user"]:
      raise Exception

    if event == "create_user":
      return self.__increment_users_count(user_id=user_id)

  def __increment_users_count(self, user_id):
    invoice_date = datetime.strptime(self.get_cycle(), '%Y-%m-%dT%H:%M:%S')
    histories = self.billing.list_history(user_id)
    for history in histories:
      if history["invoice_date"] == invoice_date.strftime('%Y/%m/%d'):
        self.logger.info("users count was incremented. need to update bill.")
        users_count = history["users_count"] + 1
    history = "history_" + invoice_date.strftime('%Y%m')
    return self.billing.update(
        user_id=user_id, 
        history=history,
        raw_price=self.calc_price(users_count, raw=True), 
        tax=TAX, 
        users_count=users_count
    )
